"use strict";(self.webpackChunkflasher=self.webpackChunkflasher||[]).push([[448],{3448:(e,s,t)=>{function i(e){return e.toString(16).padStart(2,"0")}function r(e){return e.toString(16).padStart(4,"0")}function _(e){return e.toString(16).padStart(8,"0")}function a(e){return Array.from(e,i)}function h(e){return new Promise((function(s,t){setTimeout(s,1e3*e)}))}t.r(s),t.d(s,{STLink:()=>ee});const n=class extends Error{},l=class extends Error{},f=class extends Error{constructor(e,s,t=!1){super(e),e instanceof DOMException&&"Device unavailable."==e.message&&(t=!0),this.address=s,this.fatal=t}toString(){if(this.address){return"0x"+i(this.address)+": "+this.message}return this.message}},o=[{version:"V2",idVendor:1155,idProduct:14152,outPipe:2,inPipe:129},{version:"V2-1",idVendor:1155,idProduct:14155,outPipe:1,inPipe:129}];const m=o.map((e=>({vendorId:e.idVendor,productId:e.idProduct}))),z=242,d=1024,p=[[4e6,0],[18e5,1],[12e5,2],[95e4,3],[48e4,7],[24e4,15],[125e3,31],[1e5,40],[5e4,79],[25e3,158],[15e3,265],[5e3,798]];class c{constructor(e,s){this._connector=e,this._dbg=s}_debug(e){this._dbg&&this._dbg.debug(e)}async init(e=18e5){await this.read_version(),await this.leave_state(),await this.read_target_voltage(),this._ver_jtag>=22&&await this.set_swd_freq(e),await this.enter_debug_swd(),await this.read_coreid()}async clean_exit(){1&this._connector.xfer_counter&&await this._connector.xfer([245],{rx_len:2})}async read_version(){let e=(await this._connector.xfer([241,128],{rx_len:6,retry:2})).getUint16(0),s=this._connector.version;if(this._ver_stlink=e>>12&15,this._ver_jtag=e>>6&63,this._ver_swim="V2"===s?63&e:null,this._ver_mass="V2-1"===s?63&e:null,this._ver_api=this._ver_jtag>11?2:1,this._ver_str=`${s} V${this._ver_stlink}J${this._ver_jtag}`,"V2"===s&&(this._ver_str+="S"+this._ver_swim),"V2-1"===s&&(this._ver_str+="M"+this._ver_mass),1===this.ver_api)throw new l(`ST-Link/${this._ver_str} is not supported, please upgrade firmware.`);if(this.ver_jtag<21)throw new l(`ST-Link/${this._ver_str} is not recent firmware, please upgrade first - functionality is not guaranteed.`)}get maximum_transfer_size(){return d}get ver_stlink(){return this._ver_stlink}get ver_jtag(){return this._ver_jtag}get ver_mass(){return this._ver_mass}get ver_swim(){return this._ver_swim}get ver_api(){return this._ver_api}get ver_str(){return this._ver_str}async read_target_voltage(){let e=await this._connector.xfer([247],{rx_len:8}),s=e.getUint32(0,!0),t=e.getUint32(4,!0);this._target_voltage=0!==s?2*t*1.2/s:null}get target_voltage(){return this._target_voltage}async read_coreid(){let e=await this._connector.xfer([z,34],{rx_len:4});this._coreid=e.getUint32(0,!0)}get coreid(){return this._coreid}async leave_state(){let e=(await this._connector.xfer([245],{rx_len:2})).getUint8(0);0===e?(this._debug("Leaving state DFU"),await this._connector.xfer([243,7])):2===e?(this._debug("Leaving state DEBUG"),await this._connector.xfer([z,33])):3===e&&(this._debug("Leaving state is SWIM"),await this._connector.xfer([244,1]))}async set_swd_freq(e=18e5){for(let[s,t]of p)if(e>=s){let e=[z,67,t];if(128!==(await this._connector.xfer(e,{rx_len:2})).getUint8(0))throw new n("Error switching SWD frequency");return void this._debug(`Set SWD frequency to ${s}Hz`)}throw new n("Selected SWD frequency is too low")}async enter_debug_swd(){await this._connector.xfer([z,48,163],{rx_len:2}),this._debug("Entered SWD debug mode")}async debug_resetsys(){await this._connector.xfer([z,50],{rx_len:2}),this._debug("Sent reset")}set_debugreg32(e,s){if(e%4)throw new n("get_mem_short address is not in multiples of 4");let t=new ArrayBuffer(10),i=new DataView(t);return i.setUint8(0,z),i.setUint8(1,53),i.setUint32(2,e,!0),i.setUint32(6,s,!0),this._connector.xfer(t,{rx_len:2})}async get_debugreg32(e){if(e%4)throw new n("get_mem_short address is not in multiples of 4");let s=new ArrayBuffer(6),t=new DataView(s);return t.setUint8(0,z),t.setUint8(1,54),t.setUint32(2,e,!0),(await this._connector.xfer(s,{rx_len:8})).getUint32(4,!0)}async get_debugreg16(e){if(e%2)throw new n("get_mem_short address is not in even");let s=await this.get_debugreg32(4294967292&e);return e%4&&(s>>=16),65535&s}async get_debugreg8(e){let s=await this.get_debugreg32(4294967292&e);return s>>=e%4<<3,255&s}async get_reg(e){let s=[z,51,e];return(await this._connector.xfer(s,{rx_len:8})).getUint32(4,!0)}set_reg(e,s){let t=new ArrayBuffer(7),i=new DataView(t);return i.setUint8(0,z),i.setUint8(1,52),i.setUint8(2,e),i.setUint32(3,s,!0),this._connector.xfer(t,{rx_len:2})}get_mem32(e,s){if(e%4)throw new n("get_mem32: Address must be in multiples of 4");if(s%4)throw new n("get_mem32: Size must be in multiples of 4");if(s>d)throw new n(`get_mem32: Size for reading is ${s} but maximum can be 1024`);let t=new ArrayBuffer(10),i=new DataView(t);return i.setUint8(0,z),i.setUint8(1,7),i.setUint32(2,e,!0),i.setUint32(6,s,!0),this._connector.xfer(t,{rx_len:s})}set_mem32(e,s){if(e%4)throw new n("set_mem32: Address must be in multiples of 4");if(s.length%4)throw new n("set_mem32: Size must be in multiples of 4");if(s.length>d)throw new n(`set_mem32: Size for writing is ${s.length} but maximum can be 1024`);let t=new ArrayBuffer(10),i=new DataView(t);return i.setUint8(0,z),i.setUint8(1,8),i.setUint32(2,e,!0),i.setUint32(6,s.length,!0),this._connector.xfer(t,{data:s})}get_mem8(e,s){if(s>64)throw new n(`get_mem8: Size for reading is ${s} but maximum can be 64`);let t=new ArrayBuffer(10),i=new DataView(t);return i.setUint8(0,z),i.setUint8(1,12),i.setUint32(2,e,!0),i.setUint32(6,s,!0),this._connector.xfer(t,{rx_len:s})}set_mem8(e,s){if(s.length>64)throw new n(`set_mem8: Size for writing is ${s.length} but maximum can be 64`);let t=new ArrayBuffer(10),i=new DataView(t);return i.setUint8(0,z),i.setUint8(1,13),i.setUint32(2,e,!0),i.setUint32(6,s.length,!0),this._connector.xfer(t,{data:s})}}const g=[{part_no:3104,core:"CortexM0",idcode_reg:1073829888,devices:[{dev_id:1088,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[1024],devices:[{type:"STM32F030x8",flash_size:64,sram_size:8,eeprom_size:0,freq:48},{type:"STM32F051x4",flash_size:16,sram_size:8,eeprom_size:0,freq:48},{type:"STM32F051x6",flash_size:32,sram_size:8,eeprom_size:0,freq:48},{type:"STM32F051x8",flash_size:64,sram_size:8,eeprom_size:0,freq:48},{type:"STM32F058x8",flash_size:64,sram_size:8,eeprom_size:0,freq:48}]},{dev_id:1090,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F030xC",flash_size:256,sram_size:32,eeprom_size:0,freq:48},{type:"STM32F091xB",flash_size:128,sram_size:32,eeprom_size:0,freq:48},{type:"STM32F091xC",flash_size:256,sram_size:32,eeprom_size:0,freq:48},{type:"STM32F098xC",flash_size:256,sram_size:32,eeprom_size:0,freq:48}]},{dev_id:1092,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[1024],devices:[{type:"STM32F030x4",flash_size:16,sram_size:4,eeprom_size:0,freq:48},{type:"STM32F030x6",flash_size:32,sram_size:4,eeprom_size:0,freq:48},{type:"STM32F031x4",flash_size:16,sram_size:4,eeprom_size:0,freq:48},{type:"STM32F031x6",flash_size:32,sram_size:4,eeprom_size:0,freq:48},{type:"STM32F038x6",flash_size:32,sram_size:4,eeprom_size:0,freq:48}]},{dev_id:1093,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[1024],devices:[{type:"STM32F042x4",flash_size:16,sram_size:6,eeprom_size:0,freq:48},{type:"STM32F042x6",flash_size:32,sram_size:6,eeprom_size:0,freq:48},{type:"STM32F048x6",flash_size:32,sram_size:6,eeprom_size:0,freq:48},{type:"STM32F070x6",flash_size:32,sram_size:6,eeprom_size:0,freq:48}]},{dev_id:1096,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F070xB",flash_size:128,sram_size:16,eeprom_size:0,freq:48},{type:"STM32F071x8",flash_size:64,sram_size:16,eeprom_size:0,freq:48},{type:"STM32F071xB",flash_size:128,sram_size:16,eeprom_size:0,freq:48},{type:"STM32F072x8",flash_size:64,sram_size:16,eeprom_size:0,freq:48},{type:"STM32F072xB",flash_size:128,sram_size:16,eeprom_size:0,freq:48},{type:"STM32F078xB",flash_size:128,sram_size:16,eeprom_size:0,freq:48}]}]},{part_no:3168,core:"CortexM0+",idcode_reg:1073829888,devices:[{dev_id:1111,flash_size_reg:536346748,flash_driver:"STM32L0",erase_sizes:[128],devices:[{type:"STM32L011x3",flash_size:8,sram_size:2,eeprom_size:.5,freq:32},{type:"STM32L011x4",flash_size:16,sram_size:2,eeprom_size:.5,freq:32},{type:"STM32L021x4",flash_size:16,sram_size:2,eeprom_size:.5,freq:32}]},{dev_id:1061,flash_size_reg:536346748,flash_driver:"STM32L0",erase_sizes:[128],devices:[{type:"STM32L031x4",flash_size:16,sram_size:8,eeprom_size:1,freq:32},{type:"STM32L031x6",flash_size:32,sram_size:8,eeprom_size:1,freq:32},{type:"STM32L041x6",flash_size:32,sram_size:8,eeprom_size:1,freq:32}]},{dev_id:1047,flash_size_reg:536346748,flash_driver:"STM32L0",erase_sizes:[128],devices:[{type:"STM32L051x6",flash_size:32,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L051x8",flash_size:64,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L052x6",flash_size:32,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L052x8",flash_size:64,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L053x6",flash_size:32,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L053x8",flash_size:64,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L062x8",flash_size:64,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L063x8",flash_size:64,sram_size:8,eeprom_size:2,freq:32}]},{dev_id:1095,flash_size_reg:536346748,flash_driver:"STM32L0",erase_sizes:[128],devices:[{type:"STM32L071x8",flash_size:64,sram_size:20,eeprom_size:3,freq:32},{type:"STM32L071xB",flash_size:128,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L071xZ",flash_size:192,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L072x8",flash_size:64,sram_size:20,eeprom_size:3,freq:32},{type:"STM32L072xB",flash_size:128,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L072xZ",flash_size:192,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L073x8",flash_size:64,sram_size:20,eeprom_size:3,freq:32},{type:"STM32L073xB",flash_size:128,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L073xZ",flash_size:192,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L081xZ",flash_size:192,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L082xZ",flash_size:192,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L082xB",flash_size:128,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L083x8",flash_size:64,sram_size:20,eeprom_size:3,freq:32},{type:"STM32L083xB",flash_size:128,sram_size:20,eeprom_size:6,freq:32},{type:"STM32L083xZ",flash_size:192,sram_size:20,eeprom_size:6,freq:32}]}]},{part_no:3107,core:"CortexM3",idcode_reg:3758366720,devices:[{dev_id:1040,flash_size_reg:536868832,flash_driver:"STM32FP",erase_sizes:[1024],devices:[{type:"STM32F101x8",flash_size:64,sram_size:10,eeprom_size:0,freq:36},{type:"STM32F101xB",flash_size:128,sram_size:16,eeprom_size:0,freq:36},{type:"STM32F102x8",flash_size:64,sram_size:10,eeprom_size:0,freq:48},{type:"STM32F102xB",flash_size:128,sram_size:16,eeprom_size:0,freq:48},{type:"STM32F103x8",flash_size:64,sram_size:20,eeprom_size:0,freq:72},{type:"STM32F103xB",flash_size:128,sram_size:20,eeprom_size:0,freq:72}]},{dev_id:1041,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F205xB",flash_size:128,sram_size:64,eeprom_size:0,freq:120},{type:"STM32F205xC",flash_size:256,sram_size:96,eeprom_size:0,freq:120},{type:"STM32F205xE",flash_size:512,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F205xF",flash_size:768,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F205xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F207xC",flash_size:256,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F207xE",flash_size:512,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F207xF",flash_size:768,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F207xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F215xE",flash_size:512,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F215xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F217xE",flash_size:512,sram_size:128,eeprom_size:0,freq:120},{type:"STM32F217xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:120}]},{dev_id:1042,flash_size_reg:536868832,flash_driver:"STM32FP",erase_sizes:[1024],devices:[{type:"STM32F101x4",flash_size:16,sram_size:4,eeprom_size:0,freq:36},{type:"STM32F101x6",flash_size:32,sram_size:6,eeprom_size:0,freq:36},{type:"STM32F102x4",flash_size:16,sram_size:4,eeprom_size:0,freq:48},{type:"STM32F102x6",flash_size:32,sram_size:6,eeprom_size:0,freq:48},{type:"STM32F103x4",flash_size:16,sram_size:6,eeprom_size:0,freq:72},{type:"STM32F103x6",flash_size:32,sram_size:10,eeprom_size:0,freq:72}]},{dev_id:1044,flash_size_reg:536868832,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F101xC",flash_size:256,sram_size:32,eeprom_size:0,freq:36},{type:"STM32F101xD",flash_size:384,sram_size:48,eeprom_size:0,freq:36},{type:"STM32F101xE",flash_size:512,sram_size:48,eeprom_size:0,freq:36},{type:"STM32F103xC",flash_size:256,sram_size:48,eeprom_size:0,freq:72},{type:"STM32F103xD",flash_size:384,sram_size:64,eeprom_size:0,freq:72},{type:"STM32F103xE",flash_size:512,sram_size:64,eeprom_size:0,freq:72}]},{dev_id:1046,flash_size_reg:536346700,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L100x6",flash_size:32,sram_size:4,eeprom_size:2,freq:32},{type:"STM32L100x8",flash_size:64,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L100xB",flash_size:128,sram_size:10,eeprom_size:2,freq:32},{type:"STM32L151x6",flash_size:32,sram_size:10,eeprom_size:4,freq:32},{type:"STM32L151x8",flash_size:64,sram_size:10,eeprom_size:4,freq:32},{type:"STM32L151xB",flash_size:128,sram_size:16,eeprom_size:4,freq:32},{type:"STM32L152x6",flash_size:32,sram_size:10,eeprom_size:4,freq:32},{type:"STM32L152x8",flash_size:64,sram_size:10,eeprom_size:4,freq:32},{type:"STM32L152xB",flash_size:128,sram_size:16,eeprom_size:4,freq:32}]},{dev_id:1048,flash_size_reg:536868832,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F105x8",flash_size:64,sram_size:64,eeprom_size:0,freq:72},{type:"STM32F105xB",flash_size:128,sram_size:64,eeprom_size:0,freq:72},{type:"STM32F105xC",flash_size:256,sram_size:64,eeprom_size:0,freq:72},{type:"STM32F107xB",flash_size:128,sram_size:64,eeprom_size:0,freq:72},{type:"STM32F107xC",flash_size:256,sram_size:64,eeprom_size:0,freq:72}]},{dev_id:1056,flash_size_reg:536868832,flash_driver:"STM32FP",erase_sizes:[1024],devices:[{type:"STM32F100x4",flash_size:16,sram_size:4,eeprom_size:0,freq:24},{type:"STM32F100x6",flash_size:32,sram_size:4,eeprom_size:0,freq:24},{type:"STM32F100x8",flash_size:64,sram_size:8,eeprom_size:0,freq:24},{type:"STM32F100xB",flash_size:128,sram_size:8,eeprom_size:0,freq:24}]},{dev_id:1058,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F302xB",flash_size:128,sram_size:32,eeprom_size:0,freq:72},{type:"STM32F302xC",flash_size:256,sram_size:40,eeprom_size:0,freq:72},{type:"STM32F303xB",flash_size:128,sram_size:40,eeprom_size:0,freq:72},{type:"STM32F303xC",flash_size:256,sram_size:48,eeprom_size:0,freq:72},{type:"STM32F358xC",flash_size:256,sram_size:48,eeprom_size:0,freq:72}]},{dev_id:1063,flash_size_reg:536346828,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L100xC",flash_size:256,sram_size:16,eeprom_size:4,freq:32}]},{dev_id:1064,flash_size_reg:536868832,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F100xC",flash_size:256,sram_size:24,eeprom_size:0,freq:24},{type:"STM32F100xD",flash_size:384,sram_size:32,eeprom_size:0,freq:24},{type:"STM32F100xE",flash_size:512,sram_size:32,eeprom_size:0,freq:24}]},{dev_id:1065,flash_size_reg:536346700,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L100x6-A",flash_size:32,sram_size:4,eeprom_size:2,freq:32},{type:"STM32L100x8-A",flash_size:64,sram_size:8,eeprom_size:2,freq:32},{type:"STM32L100xB-A",flash_size:128,sram_size:16,eeprom_size:2,freq:32},{type:"STM32L151x6-A",flash_size:32,sram_size:16,eeprom_size:4,freq:32},{type:"STM32L151x8-A",flash_size:64,sram_size:32,eeprom_size:4,freq:32},{type:"STM32L151xB-A",flash_size:128,sram_size:32,eeprom_size:4,freq:32},{type:"STM32L152x6-A",flash_size:32,sram_size:16,eeprom_size:4,freq:32},{type:"STM32L152x8-A",flash_size:64,sram_size:32,eeprom_size:4,freq:32},{type:"STM32L152xB-A",flash_size:128,sram_size:32,eeprom_size:4,freq:32}]},{dev_id:1072,flash_size_reg:536868832,flash_driver:"STM32FPXL",erase_sizes:[2048],devices:[{type:"STM32F101xF",flash_size:768,sram_size:80,eeprom_size:0,freq:36},{type:"STM32F101xG",flash_size:1024,sram_size:80,eeprom_size:0,freq:36},{type:"STM32F103xF",flash_size:768,sram_size:96,eeprom_size:0,freq:72},{type:"STM32F103xG",flash_size:1024,sram_size:96,eeprom_size:0,freq:72}]},{dev_id:1074,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F373x8",flash_size:64,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F373xB",flash_size:128,sram_size:24,eeprom_size:0,freq:72},{type:"STM32F373xC",flash_size:256,sram_size:32,eeprom_size:0,freq:72},{type:"STM32F378xC",flash_size:256,sram_size:32,eeprom_size:0,freq:72}]},{dev_id:1078,flash_size_reg:536346828,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L151xC",flash_size:256,sram_size:32,eeprom_size:8,freq:32},{type:"STM32L151xC-A",flash_size:256,sram_size:32,eeprom_size:8,freq:32},{type:"STM32L151xD",flash_size:384,sram_size:48,eeprom_size:12,freq:32},{type:"STM32L152xC",flash_size:256,sram_size:32,eeprom_size:8,freq:32},{type:"STM32L152xC-A",flash_size:256,sram_size:32,eeprom_size:8,freq:32},{type:"STM32L152xD",flash_size:384,sram_size:48,eeprom_size:12,freq:32},{type:"STM32L162xC",flash_size:256,sram_size:32,eeprom_size:8,freq:32},{type:"STM32L162xC-A",flash_size:256,sram_size:32,eeprom_size:8,freq:32},{type:"STM32L162xD",flash_size:384,sram_size:48,eeprom_size:12,freq:32}]},{dev_id:1079,flash_size_reg:536346828,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L151xD-X",flash_size:384,sram_size:80,eeprom_size:16,freq:32},{type:"STM32L151xE",flash_size:512,sram_size:80,eeprom_size:16,freq:32},{type:"STM32L152xD-X",flash_size:384,sram_size:80,eeprom_size:16,freq:32},{type:"STM32L152xE",flash_size:512,sram_size:80,eeprom_size:16,freq:32},{type:"STM32L162xD-X",flash_size:384,sram_size:80,eeprom_size:16,freq:32},{type:"STM32L162xE",flash_size:512,sram_size:80,eeprom_size:16,freq:32}]},{dev_id:1080,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F303x6",flash_size:32,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F303x8",flash_size:64,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F328x8",flash_size:64,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F334x4",flash_size:16,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F334x6",flash_size:32,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F334x8",flash_size:64,sram_size:16,eeprom_size:0,freq:72}]},{dev_id:1081,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F301x6",flash_size:32,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F301x8",flash_size:64,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F302x6",flash_size:32,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F302x8",flash_size:64,sram_size:16,eeprom_size:0,freq:72},{type:"STM32F318x8",flash_size:64,sram_size:16,eeprom_size:0,freq:72}]},{dev_id:1094,flash_size_reg:536868812,flash_driver:"STM32FP",erase_sizes:[2048],devices:[{type:"STM32F302xD",flash_size:384,sram_size:64,eeprom_size:0,freq:72},{type:"STM32F302xE",flash_size:512,sram_size:64,eeprom_size:0,freq:72},{type:"STM32F303xD",flash_size:384,sram_size:80,eeprom_size:0,freq:72},{type:"STM32F303xE",flash_size:512,sram_size:80,eeprom_size:0,freq:72},{type:"STM32F398xE",flash_size:512,sram_size:80,eeprom_size:0,freq:72}]}]},{part_no:3108,core:"CortexM4",idcode_reg:3758366720,devices:[{dev_id:1043,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F405xE",flash_size:512,sram_size:192,eeprom_size:0,freq:168},{type:"STM32F405xG",flash_size:1024,sram_size:192,eeprom_size:0,freq:168},{type:"STM32F407xE",flash_size:512,sram_size:192,eeprom_size:0,freq:168},{type:"STM32F407xG",flash_size:1024,sram_size:192,eeprom_size:0,freq:168},{type:"STM32F415xG",flash_size:1024,sram_size:192,eeprom_size:0,freq:168},{type:"STM32F417xE",flash_size:512,sram_size:192,eeprom_size:0,freq:168},{type:"STM32F417xG",flash_size:1024,sram_size:192,eeprom_size:0,freq:168}]},{dev_id:1045,flash_size_reg:536835552,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L475xC",flash_size:256,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L475xE",flash_size:512,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L475xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L476xC",flash_size:256,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L476xE",flash_size:512,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L476xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L486xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L471xE",flash_size:512,sram_size:128,eeprom_size:0,freq:80},{type:"STM32L471xG",flash_size:1024,sram_size:128,eeprom_size:0,freq:80}]},{dev_id:1049,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F427xG",flash_size:1024,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F427xI",flash_size:2048,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F429xE",flash_size:512,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F429xG",flash_size:1024,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F429xI",flash_size:2048,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F437xG",flash_size:1024,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F437xI",flash_size:2048,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F439xG",flash_size:1024,sram_size:256,eeprom_size:0,freq:180},{type:"STM32F439xI",flash_size:2048,sram_size:256,eeprom_size:0,freq:180}]},{dev_id:1057,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F446xC",flash_size:256,sram_size:128,eeprom_size:0,freq:180},{type:"STM32F446xE",flash_size:512,sram_size:128,eeprom_size:0,freq:180}]},{dev_id:1059,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F401xB",flash_size:128,sram_size:64,eeprom_size:0,freq:84},{type:"STM32F401xC",flash_size:256,sram_size:64,eeprom_size:0,freq:84}]},{dev_id:1073,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F411xC",flash_size:256,sram_size:128,eeprom_size:0,freq:100},{type:"STM32F411xE",flash_size:512,sram_size:128,eeprom_size:0,freq:100}]},{dev_id:1075,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F401xD",flash_size:384,sram_size:96,eeprom_size:0,freq:84},{type:"STM32F401xE",flash_size:512,sram_size:96,eeprom_size:0,freq:84}]},{dev_id:1076,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F469xE",flash_size:512,sram_size:384,eeprom_size:0,freq:180},{type:"STM32F469xG",flash_size:1024,sram_size:384,eeprom_size:0,freq:180},{type:"STM32F469xI",flash_size:2048,sram_size:384,eeprom_size:0,freq:180},{type:"STM32F479xG",flash_size:1024,sram_size:384,eeprom_size:0,freq:180},{type:"STM32F479xI",flash_size:2048,sram_size:384,eeprom_size:0,freq:180}]},{dev_id:1077,flash_size_reg:536835552,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L431xB",flash_size:128,sram_size:64,eeprom_size:0,freq:80},{type:"STM32L431xC",flash_size:256,sram_size:64,eeprom_size:0,freq:80},{type:"STM32L432xB",flash_size:128,sram_size:64,eeprom_size:0,freq:80},{type:"STM32L432xC",flash_size:256,sram_size:64,eeprom_size:0,freq:80},{type:"STM32L433xB",flash_size:128,sram_size:64,eeprom_size:0,freq:80},{type:"STM32L433xC",flash_size:256,sram_size:64,eeprom_size:0,freq:80},{type:"STM32L442xC",flash_size:256,sram_size:64,eeprom_size:0,freq:80},{type:"STM32L443xC",flash_size:256,sram_size:64,eeprom_size:0,freq:80}]},{dev_id:1122,flash_size_reg:536835552,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L451xC",flash_size:256,sram_size:160,eeprom_size:0,freq:80},{type:"STM32L451xE",flash_size:512,sram_size:160,eeprom_size:0,freq:80},{type:"STM32L452xC",flash_size:256,sram_size:160,eeprom_size:0,freq:80},{type:"STM32L452xE",flash_size:512,sram_size:160,eeprom_size:0,freq:80},{type:"STM32L462xE",flash_size:512,sram_size:160,eeprom_size:0,freq:80}]},{dev_id:1089,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F412xE",flash_size:512,sram_size:256,eeprom_size:0,freq:100},{type:"STM32F412xG",flash_size:1024,sram_size:256,eeprom_size:0,freq:100}]},{dev_id:1112,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F410x8",flash_size:64,sram_size:32,eeprom_size:0,freq:100},{type:"STM32F410xB",flash_size:128,sram_size:32,eeprom_size:0,freq:100}]},{dev_id:1121,flash_size_reg:536835552,flash_driver:null,erase_sizes:[],devices:[{type:"STM32L496xE",flash_size:512,sram_size:320,eeprom_size:0,freq:80},{type:"STM32L496xG",flash_size:1024,sram_size:320,eeprom_size:0,freq:80},{type:"STM32L4A6xG",flash_size:1024,sram_size:320,eeprom_size:0,freq:80}]},{dev_id:1123,flash_size_reg:536836642,flash_driver:"STM32FS",erase_sizes:[16384,16384,16384,16384,65536,131072,131072,131072,131072,131072,131072,131072],devices:[{type:"STM32F413xG",flash_size:1024,sram_size:320,eeprom_size:0,freq:100},{type:"STM32F413xH",flash_size:1536,sram_size:320,eeprom_size:0,freq:100},{type:"STM32F423xH",flash_size:1536,sram_size:320,eeprom_size:0,freq:100}]}]},{part_no:3111,core:"CortexM7",idcode_reg:3758366720,devices:[{dev_id:1097,flash_size_reg:535884866,flash_driver:"STM32FS",erase_sizes:[32768,32768,32768,32768,131072,262144,262144,262144],devices:[{type:"STM32F745xE",flash_size:512,sram_size:320,eeprom_size:0,freq:216},{type:"STM32F745xG",flash_size:1024,sram_size:320,eeprom_size:0,freq:216},{type:"STM32F746xE",flash_size:512,sram_size:320,eeprom_size:0,freq:216},{type:"STM32F746xG",flash_size:1024,sram_size:320,eeprom_size:0,freq:216},{type:"STM32F756xG",flash_size:1024,sram_size:320,eeprom_size:0,freq:216}]},{dev_id:1105,flash_size_reg:535884866,flash_driver:"STM32FS",erase_sizes:[32768,32768,32768,32768,131072,262144,262144,262144],devices:[{type:"STM32F765xG",flash_size:1024,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F765xI",flash_size:2048,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F767xG",flash_size:1024,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F767xI",flash_size:2048,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F769xG",flash_size:1024,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F769xI",flash_size:2048,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F777xI",flash_size:2048,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F778xI",flash_size:2048,sram_size:512,eeprom_size:0,freq:216},{type:"STM32F779xI",flash_size:2048,sram_size:512,eeprom_size:0,freq:216}]},{dev_id:1106,flash_size_reg:535853602,flash_driver:"STM32FS",erase_sizes:[32768,32768,32768,32768,131072,262144,262144,262144],devices:[{type:"STM32F722xC",flash_size:256,sram_size:256,eeprom_size:0,freq:216},{type:"STM32F722xE",flash_size:512,sram_size:256,eeprom_size:0,freq:216},{type:"STM32F723xC",flash_size:256,sram_size:256,eeprom_size:0,freq:216},{type:"STM32F723xE",flash_size:512,sram_size:256,eeprom_size:0,freq:216},{type:"STM32F732xE",flash_size:512,sram_size:256,eeprom_size:0,freq:216},{type:"STM32F733xE",flash_size:512,sram_size:256,eeprom_size:0,freq:216}]}]}],u={SYS_OPEN:1,SYS_CLOSE:2,SYS_WRITEC:3,SYS_WRITE0:4,SYS_WRITE:5,SYS_READ:6,SYS_READC:7,SYS_ISERROR:8,SYS_ISTTY:9,SYS_SEEK:10,SYS_FLEN:12,SYS_TMPNAM:13,SYS_REMOVE:14,SYS_RENAME:15,SYS_CLOCK:16,SYS_TIME:17,SYS_SYSTEM:18,SYS_ERRNO:19,SYS_GET_CMDLINE:21,SYS_HEAPINFO:22,SYS_ELAPSED:48,SYS_TICKFREQ:49},S=["R0","R1","R2","R3","R4","R5","R6","R7","R8","R9","R10","R11","R12","SP","LR","PC","PSR","MSP","PSP"],w=536870912,y=134217728,x=3758157068,T=3758157296,v=3758157308,b=100270080,M=100270084,F=2690580480,q=F,k=-1604386815,L=-1604386813,E=-1604386811;class R{constructor(e,s){this._stlink=e,this._dbg=s,this.FLASH_START=y,this.SRAM_START=w}is_reg(e){return S.includes(e.toUpperCase())}async get_reg_all(){let e={};for(let s of S)e[s]=await this.get_reg(s);return e}get_reg(e){this._dbg.debug(`Stm32.get_reg(${e})`);let s=S.indexOf(e.toUpperCase());if(-1!=s)return this._stlink.get_reg(s);throw new n(`Wrong register name ${e}`)}set_reg(e,s){this._dbg.debug(`Stm32.set_reg(${e}, 0x${_(s)})`);let t=S.indexOf(e.toUpperCase());if(-1!=t)return this._stlink.set_reg(t,s);throw new n("Wrong register name")}async get_mem(e,s){if(this._dbg.debug(`Stm32.get_mem(0x${_(e)}, ${s})`),0==s)return[];let t=0,i=[];if(e%4){let r=Math.min(4-e%4,s),_=await this._stlink.get_mem8(e,r);t+=_.byteLength,i.push(_)}for(;;){this._dbg.bargraph_update({value:t});let r=Math.min(s-t&4294967288,2*this._stlink.maximum_transfer_size);if(0==r)break;if(r>64){r=Math.floor(r/2);let s=await this._stlink.get_mem32(e+t,r);t+=s.byteLength,i.push(s),s=await this._stlink.get_mem32(e+t,r),t+=s.byteLength,i.push(s)}else{let s=await this._stlink.get_mem32(e+t,r);t+=s.byteLength,i.push(s)}}if(t<s){let r=s-t,_=await this._stlink.get_mem8(e+t,r);t+=_.byteLength,i.push(_)}this._dbg.bargraph_done();let r=new Uint8Array(t),a=0;for(let e of i)for(let s of new Uint8Array(e.buffer))r[a++]=s;return r}async set_mem(e,s){if(this._dbg.debug(`Stm32.set_mem(0x${_(e)}, [data:${s.length}Bytes])`),0==s.length)return;let t=0;if(e%4){let i=Math.min(4-e%4,s.length);await this._stlink.set_mem8(e,s.slice(0,i)),t=i}for(;;){this._dbg.bargraph_update({value:t});let i=Math.min(s.length-t&4294967288,2*this._stlink.maximum_transfer_size);if(0==i)break;i>64?(i=Math.floor(i/2),await this._stlink.set_mem32(e+t,s.slice(t,t+i)),t+=i,await this._stlink.set_mem32(e+t,s.slice(t,t+i)),t+=i):(await this._stlink.set_mem32(e+t,s.slice(t,t+i)),t+=i)}t<s.length&&await this._stlink.set_mem8(e+t,s.slice(t)),this._dbg.bargraph_done()}fill_mem(e,s,t){if(t>255)throw new n("Fill pattern can by 8 bit number");if(this._dbg.debug(`Stm32.fill_mem(0x${_(e)}, 0x${i(t)}d)`),0==s)return;const r=new Uint8Array(s).fill(t);return this.set_mem(e,r)}core_status(){return this._dbg.debug("Stm32.core_status()"),this._stlink.get_debugreg32(T)}async core_reset(){this._dbg.debug("Stm32.core_reset()"),await this._stlink.set_debugreg32(v,0),await this._stlink.set_debugreg32(x,M),await this._stlink.get_debugreg32(x)}async core_reset_halt(){this._dbg.debug("Stm32.core_reset_halt()"),await this._stlink.set_debugreg32(T,L),await this._stlink.set_debugreg32(v,1),await this._stlink.set_debugreg32(x,M),await this._stlink.get_debugreg32(x)}async core_halt(){this._dbg.debug("Stm32.core_halt()"),await this._stlink.set_debugreg32(T,L)}async core_step(){this._dbg.debug("Stm32.core_step()"),await this._stlink.set_debugreg32(T,E)}async core_run(){this._dbg.debug("Stm32.core_run()"),await this._stlink.set_debugreg32(T,k)}async core_nodebug(){this._dbg.debug("Stm32.core_nodebug()"),await this._stlink.set_debugreg32(T,q)}async flash_erase_all(){throw this._dbg.debug("Stm32.flash_mass_erase()"),new n("Erasing FLASH is not implemented for this MCU")}async flash_write(e,s,{erase:t=!1,verify:i=!1,erase_sizes:r=null}){let _=null!==e?"0x{H32(addr)}":"None";throw this._dbg.debug(`Stm32.flash_write(${_}, [data:${s.length}Bytes], erase=${t}, verify=${i}, erase_sizes=${r})`),new n("Programing FLASH is not implemented for this MCU")}}R.SRAM_START=w,R.FLASH_START=y,R.AIRCR_REG=x,R.DHCSR_REG=T,R.DEMCR_REG=v,R.AIRCR_KEY=b,R.AIRCR_SYSRESETREQ_BIT=4,R.AIRCR_SYSRESETREQ=M,R.DHCSR_KEY=F,R.DHCSR_DEBUGEN_BIT=1,R.DHCSR_HALT_BIT=2,R.DHCSR_STEP_BIT=4,R.DHCSR_STATUS_HALT_BIT=131072,R.DHCSR_STATUS_LOCKUP_BIT=524288,R.DHCSR_DEBUGDIS=q,R.DHCSR_DEBUGEN=k,R.DHCSR_HALT=L,R.DHCSR_STEP=E,R.DEMCR_RUN_AFTER_RESET=0,R.DEMCR_HALT_AFTER_RESET=1;const A=1073881088,C=new Uint8Array([3,136,11,128,35,104,43,66,252,209,51,66,4,208,2,48,2,49,2,58,0,42,243,209,0,190]);class D{constructor(e,s,t,i=0){this._driver=e,this._stlink=s,this._dbg=t;let r=A+64*i;this.FLASH_KEYR_REG=r+4,this.FLASH_SR_REG=r+12,this.FLASH_CR_REG=r+16,this.FLASH_AR_REG=r+20}async init(){if(await this._stlink.read_target_voltage(),this._stlink.target_voltage<2)throw new n(`Supply voltage is ${this._stlink.target_voltage.toFixed(2)}V, but minimum for FLASH program or erase is 2.0V`);await this.unlock()}async unlock(){await this._driver.core_reset_halt();let e=await this._stlink.get_debugreg32(this.FLASH_CR_REG);if(128&e&&(await this._stlink.set_debugreg32(this.FLASH_KEYR_REG,1164378403),await this._stlink.set_debugreg32(this.FLASH_KEYR_REG,3455027627)),e=await this._stlink.get_debugreg32(this.FLASH_CR_REG),128&e)throw new n("Error unlocking FLASH")}async lock(){await this._stlink.set_debugreg32(this.FLASH_CR_REG,128),await this._driver.core_reset_halt()}async erase_all(){await this._stlink.set_debugreg32(this.FLASH_CR_REG,4),await this._stlink.set_debugreg32(this.FLASH_CR_REG,68),await this.wait_busy(2,"Erasing FLASH")}async erase_page(e){await this._stlink.set_debugreg32(this.FLASH_CR_REG,2),await this._stlink.set_debugreg32(this.FLASH_AR_REG,e),await this._stlink.set_debugreg32(this.FLASH_CR_REG,66),await this.wait_busy(.2)}async erase_pages(e,s,t,i){if(void 0===i)throw new n("erase size is undefined");let r=e;for(this._dbg.bargraph_start("Erasing FLASH",{value_min:t,value_max:t+i});;)for(let e of s)if(t<r+e&&(this._dbg.bargraph_update({value:r}),await this.erase_page(r)),r+=e,t+i<r)return void this._dbg.bargraph_done()}async init_write(e){this._dbg.debug("Loading flash algorithm at 0x"+_(e)),this._flash_writer_offset=e,this._flash_data_offset=e+256,await this._stlink.set_mem8(this._flash_writer_offset,C),await this._driver.set_reg("R4",this.FLASH_SR_REG),await this._driver.set_reg("R5",1),await this._driver.set_reg("R6",32),await this._stlink.set_debugreg32(this.FLASH_CR_REG,1)}async write(e,s){if(!s.every((e=>255==e))){this._dbg.debug(`Flashing ${s.length} bytes at 0x${_(e)}`);try{this._dbg.debug("Loading working buffer at 0x"+_(this._flash_data_offset)),await this._stlink.set_mem32(this._flash_data_offset,s),await this._driver.set_reg("PC",this._flash_writer_offset),await this._driver.set_reg("R0",this._flash_data_offset),await this._driver.set_reg("R1",e),await this._driver.set_reg("R2",s.length),await this._driver.core_run(),await this.wait_for_breakpoint(.2)}catch(t){throw new n(`Failed to flash ${s.length} bytes at 0x${_(e)}: `+t)}}}async wait_busy(e,s=null){s&&this._dbg.bargraph_start(s,{value_min:Date.now()/1e3,value_max:Date.now()/1e3+e});const t=Date.now()+2*e*1e3;for(;Date.now()<t;){s&&this._dbg.bargraph_update({value:Date.now()/1e3});let t=await this._stlink.get_debugreg32(this.FLASH_SR_REG);if(!(1&t))return await this.end_of_operation(t),void(s&&this._dbg.bargraph_done());await h(e/20)}throw new n("Operation timeout")}async wait_for_breakpoint(e){const s=Date.now()+1e3*e;do{let s=await this._stlink.get_debugreg32(R.DHCSR_REG);if(this._dbg.debug("DHCSR = 0x"+_(s)),s&R.DHCSR_STATUS_LOCKUP_BIT)throw new n("Flash algorithm crashed");if(s&R.DHCSR_STATUS_HALT_BIT)break;await h(e/20)}while(Date.now()<s);let t=await this._stlink.get_debugreg32(this.FLASH_SR_REG);await this.end_of_operation(t)}async end_of_operation(e){if(32!==e)throw new n("Error writing FLASH with status (FLASH_SR) "+_(e));await this._stlink.set_debugreg32(this.FLASH_SR_REG,e)}}class U extends R{async _flash_erase_all(e=0){var s;s=new D(this,this._stlink,this._dbg,e),await s.init(),await s.erase_all(),await s.lock()}async flash_erase_all(){this._dbg.debug("Stm32FP.flash_erase_all()"),await this._flash_erase_all()}async _flash_write(e,s,{erase:t=!1,verify:i=!1,erase_sizes:r=null,bank:a=0}){if(s.length%4){let e=new Uint8Array(s.length+(4-s.length%4));s.forEach(((s,t)=>e[t]=s)),e.fill(255,s.length),s=e}let h=new D(this,this._stlink,this._dbg,a);for(await h.init(),t&&(r?await h.erase_pages(this.FLASH_START,r,e,s.length):await h.erase_all()),this._dbg.bargraph_start("Writing FLASH",{value_min:e,value_max:e+s.length}),await h.init_write(U.SRAM_START);s.length>0;){this._dbg.bargraph_update({value:e});let t=s.slice(0,this._stlink.maximum_transfer_size);if(s=s.slice(this._stlink.maximum_transfer_size),await h.write(e,t),i){this._dbg.debug(`Verifying ${t.length} bytes`);let s=await this._stlink.get_mem32(e,t.length),i=new Uint8Array(s.buffer),r=!1;if(i.length==t.length&&(r=i.every(((e,s)=>e==t[s]))),!r)throw new n("Verify error at block address: 0x"+_(e))}e+=t.length}await h.lock(),this._dbg.bargraph_done()}async flash_write(e,s,{erase:t=!1,verify:i=!1,erase_sizes:r=null}){let _=null!==e?"0x{H32(addr)}":"None";if(this._dbg.debug(`Stm32FP.flash_write(${_}, [data:${s.length}Bytes], erase=${t}, verify=${i}, erase_sizes=${r})`),null===e)e=this.FLASH_START;else if(e%2)throw new n("Start address is not aligned to half-word");await this._flash_write(e,s,arguments[2])}}const H=524288;const P=1073888260,B=1073888268,$=1073888272,I=2147483648,G=new Uint8Array([3,120,11,112,35,104,43,66,252,209,0,43,4,209,1,48,1,49,1,58,0,42,243,209,0,190]),Y=new Uint8Array([3,136,11,128,35,104,43,66,252,209,0,43,4,209,2,48,2,49,2,58,0,42,243,209,0,190]),O=[{min_voltage:2.7,max_mass_erase_time:16,max_erase_time:{16:.5,64:1.1,128:2},FLASH_CR_PSIZE:512,FLASH_WRITER_CODE:new Uint8Array([3,104,11,96,35,104,43,66,252,209,0,43,4,209,4,48,4,49,4,58,0,42,243,209,0,190])},{min_voltage:2.1,max_mass_erase_time:22,max_erase_time:{16:.6,64:1.4,128:2.6},FLASH_CR_PSIZE:256,FLASH_WRITER_CODE:Y},{min_voltage:1.8,max_mass_erase_time:32,max_erase_time:{16:.8,64:2.4,128:4},FLASH_CR_PSIZE:0,FLASH_WRITER_CODE:G}];class N{constructor(e,s,t){this._driver=e,this._stlink=s,this._dbg=t,this._params=null}async init(){this._params=await this.get_voltage_dependend_params(),await this.unlock()}async get_voltage_dependend_params(){await this._stlink.read_target_voltage();let e=this._stlink.target_voltage,s=O.find((s=>e>s.min_voltage));if(s)return s;throw new n(`Supply voltage is ${e}V, but minimum for FLASH program or erase is 1.8V`)}async unlock(){await this._driver.core_reset_halt();let e=await this._stlink.get_debugreg32($);if(e&I&&(await this._stlink.set_debugreg32(P,1164378403),await this._stlink.set_debugreg32(P,3455027627)),e=await this._stlink.get_debugreg32($),e&I)throw new n("Error unlocking FLASH")}async lock(){await this._stlink.set_debugreg32($,I),await this._driver.core_reset_halt()}async erase_all(){await this._stlink.set_debugreg32($,4),await this._stlink.set_debugreg32($,65540),await this.wait_busy(this._params.max_mass_erase_time,"Erasing FLASH")}async erase_sector(e,s){let t=2;t|=this._params.FLASH_CR_PSIZE|e<<3,await this._stlink.set_debugreg32($,t),await this._stlink.set_debugreg32($,65536|t),await this.wait_busy(this._params.max_erase_time[s])}async erase_sectors(e,s,t,i){let r=e;this._dbg.bargraph_start("Erasing FLASH",{value_min:e,value_max:e+i});let _=0;for(;;)for(let e of s){if(t<r+e&&(this._dbg.bargraph_update({value:r}),await this.erase_sector(_,e)),r+=e,t+i<r)return void this._dbg.bargraph_done();_+=1}}async init_write(e){this._flash_writer_offset=e,this._flash_data_offset=e+256,await this._stlink.set_mem8(this._flash_writer_offset,this._params.FLASH_WRITER_CODE),await this._driver.set_reg("R4",B),await this._driver.set_reg("R5",65536),await this._stlink.set_debugreg32($,1|this._params.FLASH_CR_PSIZE)}async write(e,s){s.every((e=>255==e))||(await this._stlink.set_mem32(this._flash_data_offset,s),await this._driver.set_reg("PC",this._flash_writer_offset),await this._driver.set_reg("R0",this._flash_data_offset),await this._driver.set_reg("R1",e),await this._driver.set_reg("R2",s.length),await this._driver.core_run(),await this.wait_for_breakpoint(.2))}async wait_busy(e,s=null){const t=Date.now()+1.5*e*1e3;for(s&&this._dbg.bargraph_start(s,{value_min:Date.now()/1e3,value_max:Date.now()/1e3+e});Date.now()<t;){s&&this._dbg.bargraph_update({value:Date.now()/1e3});let t=await this._stlink.get_debugreg32(B);if(!(65536&t))return this.end_of_operation(t),void(s&&this._dbg.bargraph_done());await h(e/20)}throw new n("Operation timeout")}async wait_for_breakpoint(e){const s=Date.now()+1e3*e;do{if(await this._stlink.get_debugreg32(R.DHCSR_REG)&R.DHCSR_STATUS_HALT_BIT)break;await h(e/20)}while(Date.now()<s);let t=await this._stlink.get_debugreg32(B);this.end_of_operation(t)}end_of_operation(e){if(e)throw new n("Error writing FLASH with status (FLASH_SR) "+_(e))}}class V extends R{async flash_erase_all(){this._dbg.debug("Stm32FS.flash_erase_all()");let e=new N(this,this._stlink,this._dbg);await e.init(),await e.erase_all(),await e.lock()}async flash_write(e,s,{erase:t=!1,verify:i=!1,erase_sizes:r=null}){let a=null!==e?`0x${_(e)}`:"None";if(this._dbg.debug(`Stm32FS.flash_write(${a}, [data:${s.length}Bytes], erase=${t}, verify=${i}, erase_sizes=${r})`),null===e&&(e=this.FLASH_START),e%4)throw new n("Start address is not aligned to word");if(s.length%4){let e=new Uint8Array(s.length+(4-s.length%4));s.forEach(((s,t)=>e[t]=s)),e.fill(255,s.length),s=e}let h=new N(this,this._stlink,this._dbg);for(await h.init(),t&&(r?await h.erase_sectors(this.FLASH_START,r,e,s.length):await h.erase_all()),this._dbg.bargraph_start("Writing FLASH",{value_min:e,value_max:e+s.length}),await h.init_write(V.SRAM_START);s.length>0;){this._dbg.bargraph_update({value:e});let t=s.slice(0,this._stlink.maximum_transfer_size);if(s=s.slice(this._stlink.maximum_transfer_size),await h.write(e,t),i){let s=await this._stlink.get_mem32(e,t.length),i=new Uint8Array(s.buffer),r=!1;if(i.length==t.length&&(r=i.every(((e,s)=>e==t[s]))),!r)throw new n("Verify error at block address: 0x"+_(e))}e+=t.length}await h.lock(),this._dbg.bargraph_done()}}let W={Stm32:R,Stm32FP:U,Stm32FPXL:class extends U{async flash_erase_all(){this._dbg.debug("Stm32F1.flash_erase_all()"),await this._flash_erase_all(0),await this._flash_erase_all(1)}async flash_write(e,s,{erase:t=!1,verify:i=!1,erase_sizes:r=null}){let a=arguments[2],h=null!==e?`0x${_(e)}`:"None";var l,f,o,m;if(this._dbg.debug(`Stm32F1.flash_write(${h}, [data:${s.length}Bytes], erase=${t}, verify=${i}, erase_sizes=${r})`),null===e)e=this.FLASH_START;else if(e%2)throw new n("Start address is not aligned to half-word");e-this.FLASH_START+s.length<=H?await this._flash_write(e,s,{...a,bank:0}):e-this.FLASH_START>H?await this._flash_write(e,s,{...a,bank:1}):(l=e,f=this.FLASH_START+H,o=s.slice(0,H-(e-this.FLASH_START)),m=s.slice(H-(e-this.FLASH_START)),await this._flash_write(l,o,{...a,bank:1}),await this._flash_write(f,m,{...a,bank:1}))}},Stm32FS:V};class K{constructor(){this.queue=[],this.locked=!1,this.destroyed=!1}async lock(){if(this.destroyed)throw new Error("Mutex is no longer available");if(this.locked){let e=new Promise(((e,s)=>{this.queue.push({resolve:e,reject:s})}));await e}else this.locked=!0}unlock(){if(!this.locked)throw new Error("Mutex was already unlocked");this.queue.length>0?this.queue.shift().resolve():this.locked=!1}destroy(){for(let e of this.queue)e.reject();this.locked=!0,this.destroyed=!0,this.queue=[]}}function j(e){return s=3,e.toString(16).padStart(s,"0");var s}const Z="RUNNING",X="HALTED";class Q{constructor(e){this._webstlink=e,this.state="UNKNOWN",this.registers={},this.num_registers=void 0}update_state(e,s){const t=this.state;e.halted?(this.state=X,(t!=X&&"RESET"!=t||s)&&(this.invalidate_registers(),this._webstlink._dispatch_callback("halted",e))):"DEBUG_RUNNING"!=t&&(this.state=Z,(t!=Z||s)&&(this.invalidate_registers(),this._webstlink._dispatch_callback("resumed",e)))}invalidate_registers(){this.registers={}}get_register(e){return this.registers[e]}set_register(e,s){this.registers[e]=s}set_num_registers(e){this.num_registers=e}has_all_registers(){return this.num_registers===Object.entries(this.registers).length}}class J{constructor(e=null){this._stlink=null,this._driver=null,this._dbg=e,this._mcu=null,this._mutex=new K,this._callbacks={inspect:[],halted:[],resumed:[]},this._callback_mutex=new K,this._cache=null}add_callback(e,s){if(void 0===this._callbacks[e])throw new Error(`No callback event type named ${e}`);if(!(s instanceof Function))throw new Error("Callback handler must be callable");this._callbacks[e].push(s)}_dispatch_callback(e,...s){let t=this._callback_mutex;!async function(i){await t.lock();try{for(let e of i){let t=e.apply(void 0,s);if(t instanceof Promise&&(t=await t),!1===t)break}}catch(s){throw new n("Error while executing callback for "+e+":"+s)}finally{t.unlock()}}(this._callbacks[e].slice(0))}async attach(e,s=null){await this._mutex.lock();try{let t=new class{constructor(e,s=null){this._dbg=s,this._dev=null,this._dev_type=null;for(let s of o)if(e.vendorId==s.idVendor&&e.productId==s.idProduct)return this._dev=e,void(this._dev_type=s);throw new n(`Unknown ST-Link/V2 type ${r(e.vendorId)}:${r(e.productId)}`)}async connect(){await this._dev.open(),1!=this._dev.configuration&&await this._dev.selectConfiguration(1);let e=this._dev.configuration.interfaces[0];e.claimed||await this._dev.claimInterface(0),null!==e.alternate&&0==e.alternate.alternateSetting||await this._dev.selectAlternateInterface(0,0)}async disconnect(){try{await this._dev.close()}catch(e){this._dbg&&this._dbg.debug("Error when disconnecting: "+e)}}get version(){return this._dev_type.version}get xfer_counter(){return this._xfer_counter}_debug(e){this._dbg&&this._dbg.debug(e)}async _write(e){if(this._dbg){const s=a(new Uint8Array(e));this._dbg.debug("  USB > "+s.join(" "))}let s;this._xfer_counter++;try{if(s=await this._dev.transferOut(this._dev_type.outPipe,e),"ok"!=s.status)throw s.status}catch(e){throw e instanceof DOMException||e.constructor==String?new f(e,this._dev_type.outPipe):e}if(s.bytesWritten!=e.length)throw new n(`Error, only ${s.bytesWritten} Bytes was transmitted to ST-Link instead of expected ${e.length}`)}async _read(e){let s,t=e;t<64?t=64:t%4&&(t+=3,t&=4092);try{if(s=await this._dev.transferIn(127&this._dev_type.inPipe,t),"ok"!=s.status)throw s.status}catch(e){throw e instanceof DOMException||e.constructor==String?new f(e,this._dev_type.inPipe):e}if(this._dbg){const e=a(new Uint8Array(s.data.buffer));this._dbg.debug("  USB < "+e.join(" "))}return s.data.byteLength>e?new DataView(s.data.buffer,s.data.byteOffset,e):s.data}async xfer(e,{data:s=null,rx_len:t=null,retry:i=0}={}){let r;if(e instanceof Array||e instanceof Uint8Array)r=e;else if(e instanceof ArrayBuffer)r=new Uint8Array(e);else{if(!(e instanceof DataView))throw new n("Unsupported command datatype "+typeof e);r=new Uint8Array(e.buffer)}if(r.length>16)throw new n(`Error too many Bytes in command: ${r.length}, maximum is 16`);let _=new Uint8Array(16);for(r.forEach(((e,s)=>_[s]=e));;){try{if(await this._write(_),s&&await this._write(s),t)return await this._read(t)}catch(e){if(e instanceof f&&!e.fatal&&i>0){this._debug("Retrying xfer after "+e),i--;continue}throw e}return}}}(e,s),i=new c(t,this._dbg);try{await t.connect();try{await i.init()}catch(e){try{await i.clean_exit()}catch(e){this._dbg&&this._dbg.warning("Error while attempting to exit cleanly: "+e)}finally{throw e}}}catch(e){try{await t.disconnect()}catch(e){this._dbg&&this._dbg.warning("Error while attempting to disconnect: "+e)}finally{throw e}}this._stlink=i,this._dbg.info("DEVICE: ST-Link/"+this._stlink.ver_str)}finally{this._mutex.unlock()}}async detach(){this._mutex.lock();try{if(null!==this._stlink){try{await this._stlink.clean_exit()}catch(e){this._dbg&&this._dbg.warning("Error while attempting to exit cleanly: "+e)}if(null!==this._stlink._connector)try{await this._stlink._connector.disconnect()}catch(e){this._dbg&&this._dbg.warning("Error while attempting to disconnect: "+e)}this._stlink=null}}finally{this._mutex.unlock()}}get connected(){return null!==this._stlink&&null!==this._stlink._connector}get examined(){return null!==this._mcu}async find_mcus_by_core(){let e=await this._stlink.get_debugreg32(3758157056);if(0==e)throw new n("Not connected to CPU");this._dbg.verbose("CPUID:  "+_(e));let s=4095&e>>4,t=g.find((e=>e.part_no==s));if(!t)throw new n(`PART_NO: 0x${j(s)} is not supported`);this._mcus_by_core=t}async find_mcus_by_devid(){let e=await this._stlink.get_debugreg32(this._mcus_by_core.idcode_reg);this._dbg.verbose("IDCODE: "+_(e));let s=4095&e,t=this._mcus_by_core.devices.find((e=>e.dev_id==s));if(!t)throw new n(`DEV_ID: 0x${j(s)} is not supported`);this._mcus_by_devid=t}async find_mcus_by_flash_size(){if(this._flash_size=await this._stlink.get_debugreg16(this._mcus_by_devid.flash_size_reg),this._mcus=this._mcus_by_devid.devices.filter((e=>e.flash_size==this._flash_size)),0==this._mcus.length)throw new n(`Connected CPU with DEV_ID: 0x${j(this._mcus_by_devid.dev_id)} and FLASH size: ${this._flash_size}KB is not supported`)}fix_cpu_type(e){if((e=e.toUpperCase()).startsWith("STM32"))return e.length>9?e.substring(0,9)+"x"+e.substring(10):e;throw new n(`"${e}" is not STM32 family`)}filter_detected_cpu(e){let s=[];for(let t of this._mcus)for(let i of e)if(i=this.fix_cpu_type(i),i.startsWith(t.type)){s.push(t);break}if(0==s.length){let s=e.join(","),t=this._mcus.map((e=>e.type)).join(",");throw this._mcus.length>1?new n(`Connected CPU is not ${s} but detected is one of ${t}`):new n(`Connected CPU is not ${s} but detected is ${t}`)}this._mcus=s}async find_sram_eeprom_size(e=null){let s=this._mcus.map((e=>e.sram_size)),t=this._mcus.map((e=>e.eeprom_size));if(this._sram_size=Math.min.apply(null,s),this._eeprom_size=Math.min.apply(null,t),this._mcus.length>1){let i=!1;if(this._sram_size!=Math.max.apply(null,s)&&(i=!0,null===e&&this._dbg.warning("Detected CPU family has multiple SRAM sizes")),this._eeprom_size!=Math.max.apply(null,t)&&(i=!0,null===e&&this._dbg.warning("Detected CPU family has multiple EEPROM sizes.")),i){let s=null;if(e){let t=await e(this._mcus);s=this._mcus.find((e=>e.type==t))}s?(this._mcu=s,this._sram_size=s.sram_size,this._eeprom_size=s.eeprom_size):(this._dbg.warning("Automatically choosing the MCU variant with the smallest flash and eeprom"),this._mcu=this._mcus.find((e=>e.sram_size==this._sram_size)))}else this._mcu=this._mcus[0]}else this._mcu=this._mcus[0];this._dbg.info(`SRAM:   ${this._sram_size}KB`),this._eeprom_size>0&&this._dbg.info(`EEPROM: ${this._eeprom_size}KB`)}load_driver(){let e=this._mcus_by_devid.flash_driver;this._driver="STM32FP"==e?new W.Stm32FP(this._stlink,this._dbg):"STM32FPXL"==e?new W.Stm32FPXL(this._stlink,this._dbg):"STM32FS"==e?new W.Stm32FS(this._stlink,this._dbg):new W.Stm32(this._stlink,this._dbg)}async detect_cpu(e,s=null){if(this._dbg.info(`SUPPLY: ${this._stlink.target_voltage.toFixed(2)}V`),this._dbg.verbose("COREID: "+_(this._stlink.coreid)),0==this._stlink.coreid)throw new n("Not connected to CPU");await this._mutex.lock();try{await this.find_mcus_by_core(),this._dbg.info("CORE:   "+this._mcus_by_core.core),await this.find_mcus_by_devid(),await this.find_mcus_by_flash_size(),e.length>0&&this.filter_detected_cpu(e),this._dbg.info("MCU:    "+this._mcus.map((e=>e.type)).join("/")),this._dbg.info(`FLASH:  ${this._flash_size}KB`),await this.find_sram_eeprom_size(s),this.load_driver(),this._last_cpu_status=null;const t={part_no:this._mcus_by_core.part_no,core:this._mcus_by_core.core,dev_id:this._mcus_by_devid.dev_id,type:this._mcu.type,flash_size:this._flash_size,sram_size:this._sram_size,flash_start:this._driver.FLASH_START,sram_start:this._driver.SRAM_START,eeprom_size:this._eeprom_size,freq:this._mcu.freq};return this._cache=new Q(this),t}finally{this._mutex.unlock()}}async _unsafe_inspect_cpu(e=!1){let s=await this._driver.core_status();0!=(s&W.Stm32.DHCSR_STATUS_LOCKUP_BIT)&&(this._dbg.verbose("Clearing lockup"),await this._driver.core_halt(),s=await this._driver.core_status());let t={halted:0!=(s&W.Stm32.DHCSR_STATUS_HALT_BIT),debug:0!=(s&W.Stm32.DHCSR_DEBUGEN_BIT)};return this._last_cpu_status=t,this._dispatch_callback("inspect",t),this._cache.update_state(t,e),t}async inspect_cpu(){await this._mutex.lock();try{return await this._unsafe_inspect_cpu()}finally{this._mutex.unlock()}}get last_cpu_status(){return this._last_cpu_status}async set_debug_enable(e){await this._mutex.lock();try{e?await this._driver.core_run():await this._driver.core_nodebug(),await this._unsafe_inspect_cpu()}finally{this._mutex.unlock()}}async step(){await this._mutex.lock();try{await this._driver.core_step(),await this._unsafe_inspect_cpu(!0)}finally{this._mutex.unlock()}}async halt(){await this._mutex.lock();try{await this._driver.core_halt(),await this._unsafe_inspect_cpu()}finally{this._mutex.unlock()}}async run(){await this._mutex.lock();try{await this._driver.core_run(),await this._unsafe_inspect_cpu()}finally{this._mutex.unlock()}}async reset(e){await this._mutex.lock();try{e?await this._driver.core_reset_halt():await this._driver.core_reset(),await this._unsafe_inspect_cpu(!0)}finally{this._mutex.unlock()}}async read_registers(){await this._mutex.lock();try{return await this._unsafe_read_registers()}finally{this._mutex.unlock()}}async read_register(e){await this._mutex.lock();try{return await this._unsafe_read_register(e)}finally{this._mutex.unlock()}}async read_instruction(e){await this._mutex.lock();try{void 0===e&&(e=await this._unsafe_read_register("PC"));const s=4294967294&e;return await this._stlink.get_debugreg16(s)}finally{this._mutex.unlock()}}async read_memory(e,s){await this._mutex.lock();try{return await this._driver.get_mem(e,s)}finally{this._mutex.unlock()}}async flash(e,s){if(s instanceof ArrayBuffer)s=new Uint8Array(s);else if(s instanceof DataView)s=new Uint8Array(s.buffer);else if(s instanceof Array){let e=new Uint8Array(s.length);for(let e=0;e<s.length;e++)if("number"!=typeof s[e]||s[e]<0||s[e]>255)throw new n(`Datum at index ${e} is not a valid octet: ${s[e]}`);s=e}else if(!(s instanceof Uint8Array))throw new n(`Data of type ${typeof s} is not supported`);await this._mutex.lock();try{await this._driver.flash_write(e,s,{erase:!0,verify:!0,erase_sizes:this._mcus_by_devid.erase_sizes}),this._cache.invalidate_registers(),await this._unsafe_inspect_cpu(!0)}finally{this._mutex.unlock()}}async _unsafe_read_register(e){let s=this._cache.get_register(e);return void 0!==s||(s=await this._driver.get_reg(e),this._cache.set_register(e,s)),s}async _unsafe_read_registers(){if(this._cache.has_all_registers())return this._cache.registers;{let e=await this._driver.get_reg_all();return this._cache.set_num_registers(Object.entries(e).length),this._cache.registers=e,e}}async _unsafe_set_register(e,s){await this._driver.set_reg(e,s),this._cache.set_register(e,s)}async _unsafe_read_semihost_params(e,s){let t=await this._driver.get_mem(e,4*s),i=new DataView(t.buffer),r=[];for(let e=0;e<s;e++)r.push(i.getUint32(4*e,!0));return r}async _unsafe_read_semihost_operation(){let e=await this._unsafe_read_register("R0"),s=await this._unsafe_read_register("R1"),t={opcode:e};const i=u;if(e==i.SYS_OPEN){let e=await this._unsafe_read_semihost_params(s,3),[i,r,_]=e;const a=["r","rb","r+","r+b","w","wb","w+","w+b","a","ab","a+","a+b"];let h=await this._driver.get_mem(i,_);t.mode=a[r],t.filename=String.fromCharCode.apply(void 0,h)}else if(e==i.SYS_CLOSE){let e=await this._unsafe_read_semihost_params(s,1);[t.handle]=e}else if(e==i.SYS_WRITE){let e=await this._unsafe_read_semihost_params(s,3),[i,r,_]=e;t.handle=i,t.data=await this._driver.get_mem(r,_)}else if(e==i.SYS_ISTTY){let e=await this._unsafe_read_semihost_params(s,1);[t.handle]=e}else if(e==i.SYS_FLEN){let e=await this._unsafe_read_semihost_params(s,1);[t.handle]=e}return t}async handle_semihosting(e){await this._mutex.lock();try{let s=await this._unsafe_read_register("PC");const t=4294967294&s;if(48811!=await this._stlink.get_debugreg16(t))return!1;let i=e(await this._unsafe_read_semihost_operation());if(parseInt(i)!=i)throw new n("Non-numeric semihost syscall result "+i);return await this._unsafe_set_register("R0",i),await this._unsafe_set_register("PC",s+2),await this._driver.core_run(),await this._unsafe_inspect_cpu(!0),!0}finally{this._mutex.unlock()}}}class ee{constructor(e){this.term=e,this.stlink=null,this.device=null}log(e){this.term.writeln(e)}debug(e){}verbose(e){}info(e){this.log("[INFO] "+e)}error(e){this.log("[ERROR] "+e)}warning(e){this.log("[WARN] "+e)}bargraph_start(e,{value_min:s=0,value_max:t=100}){this._msg=e,this._bargraph_min=s,this._bargraph_max=t}bargraph_update({value:e=0,percent:s=null}){null===s&&(s=this._bargraph_max-this._bargraph_min>0?Math.floor(100*(e-this._bargraph_min)/(this._bargraph_max-this._bargraph_min)):0),s>100&&(s=100),this.info(`${this._msg}: ${s}%`),document.getElementById("progressBar").value=s,document.getElementById("status").innerHTML=`${this._msg}: ${s}% uploaded... please wait`}bargraph_done(){this.info(`${this._msg}: complete`),document.getElementById("progressBar").value=100,document.getElementById("status").innerHTML=`${this._msg}: Complete`}update_debugger_info(e,s){const t="ST-Link/"+e._stlink.ver_str;this.log(`Debugger - ${t} - Connected`),this.log(s.productName),this.log(s.manufacturerName),this.log(s.serialNumber)}update_target_status(e,s=null){if(null!==s){this.log("target type: "+s.type);const e=[["type","Type",""],["core","Core",""],["dev_id","Device ID",""],["flash_size","Flash Size","KiB"],["sram_size","SRAM Size","KiB"]];s.eeprom_size>0&&e.push(["eeprom_size","EEPROM Size","KiB"]);for(const[t,i,r]of e)this.log(i+": "+s[t]+r)}const t=e.halted?"Halted":"Running",i="Debugging "+(e.debug?"Enabled":"Disabled");this.log(`${t}, ${i}`)}on_successful_attach=async(e,s)=>{this.stlink=e,this.device=s,this.update_debugger_info(e,s),this.target=await e.detect_cpu(this.config.stlink.cpus,null);const t=this;function i(e){t.update_target_status(e,null)}e.add_callback("halted",i),e.add_callback("resumed",i);let r=await e.inspect_cpu();r.debug||(await e.set_debug_enable(!0),r=await e.inspect_cpu()),this.update_target_status(r,this.target),this.log("SRAM address = 0x"+this.target.sram_start.toString(16)),this.log("Flash adddress = 0x"+this.target.flash_start.toString(16))};on_disconnect=()=>{this.info("Device disconnected"),this.stlink=null,this.device=null};connect=async(e,s,t,i)=>{this.config=e,this.firmwareUrl=s,this.options=t,null!==this.stlink&&(await this.stlink.detach(),this.on_disconnect());try{const e=await navigator.usb.requestDevice({filters:m});navigator.usb.ondisconnect=s=>{s.device===e&&i()};const s=new J(this);await s.attach(e,this),this.stlink=s,this.device=e}catch(e){this.error(e)}if(null!==this.stlink)return await this.on_successful_attach(this.stlink,this.device),"ST-Link/"+this.stlink._stlink.ver_str;throw new Error("not connected")};checkStatus=e=>{if(!e.ok)throw new Error(`HTTP ${e.status} - ${e.statusText}`);return e};fetch_file=async(e,s=(e=>e))=>{const t=await fetch(e),i=await this.checkStatus(t).blob();return s(await new Promise(((e,s)=>{const t=new FileReader;t.onload=function(){e(t.result)},t.readAsArrayBuffer(i)})))};flash=async(e,s,t)=>{if(this.progressCallback=t,null!==this.stlink&&this.stlink.connected){if(s){this.log("\nFlash bootloader"),this.log("================");const e=await this.fetch_file("firmware/"+document.getElementById("version").value+"/bootloader/"+this.config.stlink.bootloader);try{await this.stlink.halt(),await this.stlink.flash(this.target.flash_start,e)}catch(e){throw this.error(e),e}}const t=parseInt(this.config.stlink.offset,16);this.log("\nFlash ExpressLRS"),this.log("================");try{await this.stlink.halt(),await this.stlink.flash(this.target.flash_start+t,e[0])}catch(e){throw this.error(e),e}}}}}}]);
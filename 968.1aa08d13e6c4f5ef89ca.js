"use strict";(self.webpackChunkflasher=self.webpackChunkflasher||[]).push([[968],{5968:(e,t,i)=>{i.r(t),i.d(t,{XmodemFlasher:()=>h});var s=i(734),r=i(2180),n=i(7973);const o=function(){},a=function(){};class l{XMODEM_MAX_TIMEOUTS=5;XMODEM_MAX_ERRORS=10;XMODEM_CRC_ATTEMPTS=3;XMODEM_OP_MODE="crc";XMODEM_START_BLOCK=1;timeout_seconds=10;block_size=128;constructor(e,t){this.device=e,this.logger=t}emit=(e,t)=>{console.log(`${e}: ${t}`)};crc16xmodem=function(e){let t=0;for(let i=0;i<e.length;i++){let s=t>>>8&255;s^=255&e[i],s^=s>>>4,t=t<<8&65535,t^=s,s=s<<5&65535,t^=s,s=s<<7&65535,t^=s}return t};send=async e=>{const t=this,i=[];let s=this.XMODEM_START_BLOCK,r=!1;o(e.length);for(let e=0;e<this.XMODEM_START_BLOCK;e++)i.push("");for(;e.length>0;){const t=e.slice(0,this.block_size),s=new Uint8Array(this.block_size);s.set(t,0);for(let e=t.length;e<this.block_size;e++)s[e]=26;e=e.slice(this.block_size),i.push(s)}let n=!0;t.emit("ready",i.length-1);const l=this.sendBlock,h=this.write,c=async e=>{if(67===e[0]&&s===t.XMODEM_START_BLOCK)o("[SEND] - received C byte for CRC transfer!"),t.XMODEM_OP_MODE="crc",i.length>s&&(t.emit("start",t.XMODEM_OP_MODE),await l(s,i[s],t.XMODEM_OP_MODE),t.emit("send",s),s++);else if(21===e[0]&&s===t.XMODEM_START_BLOCK)o("[SEND] - received NAK byte for standard checksum transfer!"),t.XMODEM_OP_MODE="normal",i.length>s&&(t.emit("start",t.XMODEM_OP_MODE),await l(s,i[s],t.XMODEM_OP_MODE),t.emit("send",s),s++);else if(6===e[0]&&s>t.XMODEM_START_BLOCK)if(o("ACK RECEIVED"),t.emit("recv","ACK"),i.length>s){if(await l(s,i[s],t.XMODEM_OP_MODE),t.emit("send",s),s++,s%10==0){const e=Math.floor(100*s/i.length);t.logger.log(`${e}% uploaded...`),document.getElementById("progressBar").value=e,document.getElementById("status").innerHTML=`Flashing: ${e}% uploaded... please wait`}}else i.length===s&&(!1===r?(r=!0,o("WE HAVE RUN OUT OF STUFF TO SEND, EOT EOT!"),t.emit("send","EOT"),await h(new Uint8Array([4]))):(o("[SEND] - Finished!"),t.emit("stop",0),document.getElementById("progressBar").value=100,document.getElementById("status").innerHTML="Flashing complete",n=!1));else 21===e[0]&&s>t.XMODEM_START_BLOCK?s===i.length&&r?(o("[SEND] - Resending EOT, because receiver responded with NAK."),t.emit("send","EOT"),await h(new Uint8Array([4]))):(o("[SEND] - Packet corruption detected, resending previous block."),t.emit("recv","NAK"),s--,i.length>s&&(await l(s,i[s],t.XMODEM_OP_MODE),t.emit("send",s),s++)):(a("GOT SOME UNEXPECTED DATA which was not handled properly!"),a("===>"),a(e),a("<==="),a("blockNumber: "+s))};for(;n;){const e=this.device.readable.getReader(),{value:t,done:i}=await e.read();if(i)throw e.releaseLock(),new Error("cancelled");e.releaseLock(),await c(t)}this.logger.log("Flash complete!")};sendBlock=async(e,t,i)=>{function s(e,t){const i=new Uint8Array(e.byteLength+t.byteLength);return i.set(e,0),i.set(t,e.byteLength),i}let r=0,n=s(new Uint8Array([1,e,255-e]),t);if(o("SENDBLOCK! Data length: "+t.byteLength),o(n),"crc"===i){const e=this.crc16xmodem(t);n=s(n,new Uint8Array([e>>>8&255,255&e]))}else{for(let e=3;e<n.byteLength;e++)r+=n.readUInt8(e);r%=256,n=s(n,new Uint8Array([r]))}o("Sending buffer with total length: "+n.length),await this.write(n)};write=async e=>{const t=this.device.writable.getWriter();await t.write(e.buffer),t.releaseLock()}}class h{constructor(e,t,i,s,r,n,o){this.device=e,this.config=s,this.options=r,this.firmwareUrl=n,this.terminal=o,this.xmodem=new l(this.device,this)}_sleep(e){return new Promise((t=>setTimeout(t,e)))}log(e){this.terminal.writeln(e)}connect=async()=>(this.config.firmware.startsWith("GHOST")?this.init_seq1=r.F.get_init_seq("GHST"):this.init_seq1=r.F.get_init_seq("CRSF"),this.transport=new s.M(this.device,!0),await this.transport.connect({baud:42e4}),this.passthrough=new r.Z(this.transport,this.terminal,this.config.firmware),"XModem Flasher");flash=async(e,t=!1)=>{this.log("Beginning flash..."),this.transport.set_delimiters(["CCC"]);let i=(await this.transport.read_line({timeout:2e3})).endsWith("CCC");if(i)this.log("\nWe were already in bootloader\n");else{let e=500;await this.passthrough.betaflight(),this.transport.set_delimiters(["CCC"]);if(i=(await this.transport.read_line({timeout:2e3})).endsWith("CCC"),i)this.log("\nWe were already in bootloader\n");else{this.transport.set_delimiters(["\n","CCC"]);let s=0;for(this.log("\nAttempting to reboot into bootloader...\n");!i;){if(s++,s>10)throw await(0,n.Q)({type:"error",title:"Flashing Failed",message:"Failed to enter bootloader mode in a reasonable time"}),new Error("[FAILED] to get to BL in reasonable time");this.log(`[${s}] retry...`),await this.transport.write(this.init_seq1);const r=Date.now();do{const s=await this.transport.read_line({timeout:2e3});if(""===s)continue;if(-1!==s.indexOf("BL_TYPE")){const t=s.substring(8).trim();this.log(`    Bootloader type found : '${t}`),e=100;continue}const r=s.match(/=== (?<version>[vV].*) ===/);if(r&&r.groups&&r.groups.version)this.log(`    Bootloader version found : '${r.groups.version}'`);else{if(-1!==s.indexOf("hold down button")){this._sleep(e),await this.transport.write_string("bbbbbb"),i=!0;break}if(-1!==s.indexOf("CCC")){i=!0;break}if(-1!==s.indexOf("_RX_")){const e=this.config.firmware.toUpperCase();if(s.trim()!==e&&!t){if("confirm"===await(0,n.Q)({type:"question",title:"Targets Mismatch",message:`Wrong target selected your RX is '${s.trim()}', trying to flash '${e}'`,confirmText:"Flash anyway",cancelText:"Cancel"})){t=!0;continue}return void this.log(`Wrong target selected your RX is '${s.trim()}', trying to flash '${e}'`)}""!==e&&this.log(`Verified RX target '${e}'`)}}}while(Date.now()-r<2e3)}this.log(`    Got into bootloader after: ${s} attempts`),this.log("Wait sync..."),this.transport.set_delimiters(["CCC"]);if(-1===(await this.transport.read_line({timeout:15e3})).indexOf("CCC"))return await(0,n.Q)({type:"error",title:"Flashing Failed",message:"Unable to communicate with bootloader"}),void this.log("[FAILED] Unable to communicate with bootloader...");this.log(" sync OK\n")}}return this.xmodem.send(e[0])};checkStatus=e=>{if(!e.ok)throw new Error(`HTTP ${e.status} - ${e.statusText}`);return e};fetchFile=async(e,t=(e=>e))=>{const i=await fetch(e),s=await this.checkStatus(i).blob();return t(await new Promise(((e,t)=>{const i=new FileReader;i.onload=function(){e(new Uint8Array(i.result))},i.readAsArrayBuffer(s)})))}}}}]);